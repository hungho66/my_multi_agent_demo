from typing import TypedDict, Annotated, Sequence, List, Dict, Any, Optional
import operator
from langchain_core.messages import BaseMessage, AIMessage, HumanMessage
from pydantic import BaseModel, Field
import json
from rich.console import Console
from rich.syntax import Syntax
from rich.panel import Panel
from ..utils.progress import progress_tracker # Import progress_tracker

console = Console(width=120, log_time=False, log_path=False)

class PlanStep(BaseModel):
    """A specific step in the execution plan generated by PlannerAgent."""
    task_id: str = Field(description="Unique identifier for this task, e.g., 'task_001'.")
    task_description: str = Field(description="Detailed description of the task to be performed.")
    agent_or_tool_name: str = Field(description="Name of the agent or tool. E.g., 'search_executor', 'weather_executor'.")
    required_input: Dict[str, Any] = Field(description="Dictionary containing input for the agent/tool. E.g., {'query': 'AI news'} or {'city': 'Hanoi'}.")
    reasoning: Optional[str] = Field(default=None, description="Brief explanation of why this step is necessary.")

class Plan(BaseModel):
    """The overall execution plan generated by PlannerAgent."""
    original_query: str = Field(description="The original query from the user.")
    thought: str = Field(description="The thought process of PlannerAgent to generate this plan.")
    steps: List[PlanStep] = Field(description="A list of PlanStep objects.")

class ToolExecutionResult(BaseModel):
    """Stores the result (or error) from executing a tool by ExecutionAgent."""
    task_id: str = Field(description="Identifier of the corresponding task in the plan.")
    task_description: Optional[str] = Field(None, description="Description of the executed task (from PlanStep).")
    tool_name: str = Field(description="Name of the tool that was called.")
    tool_input: Dict[str, Any] = Field(description="Input data provided to the tool.")
    raw_output: Any = Field(description="Raw output returned from the tool.")
    error: Optional[str] = Field(default=None, description="Error message if any issue occurred during tool execution.")
    is_successful: bool = Field(default=True, description="True if the tool executed successfully.")

class Analysis(BaseModel):
    """Result of information analysis from AnalysisAgent."""
    original_query: str = Field(description="The original user query.")
    analysis_summary: str = Field(description="Summary of the analysis based on collected information.")
    key_insights: List[str] = Field(description="List of key information points or insights derived.")
    sentiment: str = Field(description="Overall sentiment of the analyzed information (e.g., 'positive', 'negative', 'neutral').")
    data_sources_quality: str = Field(description="Brief assessment of the quality and reliability of the data sources.")
    reasoning_process: Optional[str] = Field(default=None, description="Description of AnalysisAgent's reasoning process.")

class FinalSummary(BaseModel):
    """Final summary generated by SummaryAgent to answer the user."""
    original_query: str = Field(description="The original user query.")
    overall_answer: str = Field(description="Comprehensive and coherent answer to the query.")
    confidence_level: str = Field(description="Estimated confidence level in the answer (High, Medium, Low).")
    limitations: Optional[str] = Field(default=None, description="Any limitations, missing information, or assumptions made.")

def merge_tool_execution_results(
    left: List[ToolExecutionResult], right: List[ToolExecutionResult]
) -> List[ToolExecutionResult]:
    return left + right

class AgentState(TypedDict):
    """
    Represents the state of the graph. Includes all information passed between agents.
    """
    query: str
    plan: Optional[Plan]
    executed_tool_results: Annotated[List[ToolExecutionResult], merge_tool_execution_results]
    analysis_result: Optional[Analysis]
    summary: Optional[FinalSummary]
    messages: Annotated[Sequence[BaseMessage], operator.add]
    sender_agent: Optional[str]
    error_message: Optional[str]

def show_agent_reasoning(output: Any, agent_name: str, color: str = "cyan"):
    """
    Prints the output (typically "thoughts" or results) of an agent in a formatted way.
    Uses Rich for aesthetically pleasing display of JSON and other data structures.
    """
    console.rule(f"[bold {color}]{agent_name}[/bold {color}]", style=color, characters="‚ïê")
    if hasattr(output, 'model_dump_json') and callable(output.model_dump_json):
        try:
            json_str = output.model_dump_json(indent=2)
            syntax = Syntax(json_str, "json", theme="material", line_numbers=False, word_wrap=True)
            console.print(syntax)
        except Exception:
            console.print(output)
    elif hasattr(output, 'model_dump') and callable(output.model_dump):
        try:
            data_to_print = output.model_dump()
            json_str = json.dumps(data_to_print, indent=2, ensure_ascii=False)
            syntax = Syntax(json_str, "json", theme="material", line_numbers=False, word_wrap=True)
            console.print(syntax)
        except Exception:
            console.print(output)
    elif isinstance(output, (dict, list)):
        try:
            json_str = json.dumps(output, indent=2, ensure_ascii=False)
            syntax = Syntax(json_str, "json", theme="material", line_numbers=False, word_wrap=True)
            console.print(syntax)
        except Exception:
            console.print(output)
    elif isinstance(output, str):
        try:
            parsed_json = json.loads(output)
            json_str = json.dumps(parsed_json, indent=2, ensure_ascii=False)
            syntax = Syntax(json_str, "json", theme="material", line_numbers=False, word_wrap=True)
            console.print(syntax)
        except json.JSONDecodeError:
            console.print(Panel(output, expand=False, border_style="dim " + color, padding=(0,1)))
    else:
        console.print(output)
    console.print("") 