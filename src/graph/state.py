from typing import TypedDict, Annotated, Sequence, List, Dict, Any, Optional
import operator
from langchain_core.messages import BaseMessage, AIMessage, HumanMessage
from pydantic import BaseModel, Field, field_validator
import json
from rich.console import Console
from rich.syntax import Syntax
from rich.panel import Panel
from ..utils.progress import progress_tracker # Import progress_tracker

console = Console(width=120, log_time=False, log_path=False)

class PlanStep(BaseModel):
    """A specific step in the execution plan generated by PlannerAgent."""
    task_id: str = Field(description="Unique identifier for this task, e.g., 'task_001'.")
    task_description: str = Field(description="Detailed description of the task to be performed.")
    agent_or_tool_name: str = Field(description="Name of the agent or tool. E.g., 'search_executor', 'weather_executor'.")
    required_input: Dict[str, Any] = Field(description="Dictionary containing input for the agent/tool. E.g., {'query': 'AI news'} or {'city': 'Hanoi'}.")
    reasoning: Optional[str] = Field(default=None, description="Brief explanation of why this step is necessary.")
    
    # Validator để tự động chuyển đổi chuỗi JSON thành dictionary
    @field_validator('required_input', mode='before')
    @classmethod
    def process_required_input(cls, v):
        # Nếu required_input là chuỗi, thử parse như JSON
        if isinstance(v, str):
            try:
                return json.loads(v)
            except json.JSONDecodeError:
                # Nếu không phải JSON hợp lệ, tạo dict đơn giản
                return {"query": v}
        
        # Nếu không phải dictionary, bọc lại thành dictionary
        if not isinstance(v, dict):
            return {"query": str(v)}
            
        return v

class Plan(BaseModel):
    """The overall execution plan generated by PlannerAgent."""
    original_query: str = Field(description="The original query from the user.")
    thought: str = Field(description="The thought process of PlannerAgent to generate this plan.")
    steps: List[PlanStep] = Field(description="A list of PlanStep objects.")

class ToolExecutionResult(BaseModel):
    """Stores the result (or error) from executing a tool by ExecutionAgent."""
    task_id: str = Field(description="Identifier of the corresponding task in the plan.")
    task_description: Optional[str] = Field(None, description="Description of the executed task (from PlanStep).")
    tool_name: str = Field(description="Name of the tool that was called.")
    tool_input: Dict[str, Any] = Field(description="Input data provided to the tool.")
    raw_output: Any = Field(description="Raw output returned from the tool.")
    error: Optional[str] = Field(default=None, description="Error message if any issue occurred during tool execution.")
    is_successful: bool = Field(default=True, description="True if the tool executed successfully.")

class Analysis(BaseModel):
    """Result of information analysis from AnalysisAgent."""
    original_query: str = Field(description="The original user query.")
    analysis_summary: str = Field(description="Summary of the analysis based on collected information.")
    key_insights: List[str] = Field(description="List of key information points or insights derived.")
    sentiment: str = Field(description="Overall sentiment of the analyzed information (e.g., 'positive', 'negative', 'neutral').")
    data_sources_quality: str = Field(description="Brief assessment of the quality and reliability of the data sources.")
    reasoning_process: Optional[str] = Field(default=None, description="Description of AnalysisAgent's reasoning process.")

class FinalSummary(BaseModel):
    """Final summary generated by SummaryAgent to answer the user."""
    original_query: str = Field(description="The original user query.")
    overall_answer: str = Field(description="Comprehensive and coherent answer to the query.")
    confidence_level: str = Field(description="Estimated confidence level in the answer (High, Medium, Low).")
    limitations: Optional[str] = Field(default=None, description="Any limitations, missing information, or assumptions made.")

def merge_tool_execution_results(
    left: List[ToolExecutionResult], right: List[ToolExecutionResult]
) -> List[ToolExecutionResult]:
    return left + right

class AgentState(TypedDict):
    """
    Represents the state of the graph. Includes all information passed between agents.
    """
    query: str
    plan: Optional[Plan]
    executed_tool_results: Annotated[List[ToolExecutionResult], merge_tool_execution_results]
    analysis_result: Optional[Analysis]
    summary: Optional[FinalSummary]
    messages: Annotated[Sequence[BaseMessage], operator.add]
    sender_agent: Optional[str]
    error_message: Optional[str]

def convert_to_serializable(obj):
    """Convert objects to JSON-serializable format recursively"""
    if hasattr(obj, "model_dump"):  # Handle Pydantic models
        return obj.model_dump()
    elif hasattr(obj, "to_dict"):  # Handle Pandas Series/DataFrame
        return obj.to_dict()
    elif hasattr(obj, "__dict__"):  # Handle custom objects
        return obj.__dict__
    elif isinstance(obj, (int, float, bool, str, type(None))):
        return obj
    elif isinstance(obj, (list, tuple)):
        return [convert_to_serializable(item) for item in obj]
    elif isinstance(obj, dict):
        return {key: convert_to_serializable(value) for key, value in obj.items()}
    else:
        return str(obj)  # Fallback to string representation

def show_agent_reasoning(output: Any, agent_name: str, color: str = "cyan"):
    """
    Prints the output (typically "thoughts" or results) of an agent in a formatted way.
    Uses Rich for aesthetically pleasing display of JSON and other data structures.
    """
    console.rule(f"[bold {color}]{agent_name}[/bold {color}]", style=color, characters="═")
    
    try:
        # Chuyển đổi output thành dạng JSON-serializable
        if hasattr(output, 'model_dump_json') and callable(output.model_dump_json):
            # Sử dụng Pydantic model_dump_json nếu có
            json_str = output.model_dump_json(indent=2)
        else:
            # Chuyển đổi output thành định dạng serializable 
            serializable_output = convert_to_serializable(output)
            json_str = json.dumps(serializable_output, indent=2, ensure_ascii=False)
            
        # Hiển thị dạng JSON đã format
        syntax = Syntax(json_str, "json", theme="material", line_numbers=False, word_wrap=True)
        console.print(syntax)
    except Exception:
        # Fallback nếu không thể format
        if isinstance(output, str):
            console.print(Panel(output, expand=False, border_style="dim " + color, padding=(0,1)))
        else:
            console.print(output)
            
    console.print("") 